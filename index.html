<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Control MIDI CC - Tetris MIDI Reproducer</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        .container { display: flex; padding: 10px; }
        #gameCanvas { border: 1px solid #000; width: 400px; height: 600px; }
        #previewCanvas { border: 1px solid #000; width: 100px; height: 100px; margin-left: 10px; }
        .controls { margin-left: 10px; }
        button { margin: 5px 0; padding: 5px 10px; }
        select { margin: 5px 0; padding: 5px; }
        #noteDisplay { margin-top: 10px; font-size: 16px; color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="gameCanvas"></canvas>
        <div>
            <canvas id="previewCanvas"></canvas>
            <div class="controls">
                <select id="instrumentSelect">
                    <option value="0">Piano</option>
                    <option value="1">Organ</option>
                    <option value="2">Synth</option>
            </select>
                <button id="startButton">Iniciar</button>
                <button id="endButton" disabled>Finalizar</button>
            </div>
            <div id="noteDisplay">Nota actual: -</div>
        </div>
    </div>
    <script>
        // WebSocket connection
        const ws = new WebSocket('ws://localhost:3001');

        // Check if WebSocket is open
        function isOpen(ws) { return ws.readyState === ws.OPEN; }

        ws.addEventListener('open', () => {
            console.log('WebSocket connection opened');
        });

        ws.addEventListener('error', (error) => {
            console.error('WebSocket error:', error);
        });

        ws.addEventListener('message', (event) => {
            console.log(`Message from server: ${event.data}`);
        });

        // Canvas setup
        const gameCanvas = document.getElementById('gameCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const noteDisplay = document.getElementById('noteDisplay');
        gameCanvas.width = 400;
        gameCanvas.height = 600;
        previewCanvas.width = 100;
        previewCanvas.height = 100;
        const ctx = gameCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');
        const gridSize = 20;
        const cols = Math.floor(gameCanvas.width / gridSize);
        const rows = Math.floor(gameCanvas.height / gridSize);
        let grid = Array(rows).fill().map(() => Array(cols).fill(0));
        let lockedPieces = [];

        // Tetris piece definitions
        const pieceTypes = [
            [[1, 1], [1, 1]], // Square
            [[1, 0], [1, 0], [1, 1]], // L-shape
            [[0, 1, 0], [1, 1, 1]], // T-shape
            [[1], [1], [1], [1]] // I-shape
        ];

        const colors = ['#00FFFF', '#FF00FF', '#FFFF00', '#00FF00'];

        class TetrisPiece {
            constructor() {
                this.type = JSON.parse(JSON.stringify(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]));
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.x = Math.floor((cols - this.type[0].length) / 2);
                this.y = 0;
                this.vy = 0.5;
                this.blockSize = gridSize;
                this.instrument = parseInt(document.getElementById('instrumentSelect').value);
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                for (let row = 0; row < this.type.length; row++) {
                    for (let col = 0; col < this.type[row].length; col++) {
                        if (this.type[row][col]) {
                            ctx.fillRect(
                                (this.x + col) * this.blockSize,
                                (this.y + row) * this.blockSize,
                                this.blockSize - 2,
                                this.blockSize - 2
                            );
                        }
                    }
                }
            }

            rotate() {
                const len = this.type.length;
                const newType = Array(len).fill().map(() => Array(len).fill(0));
                for (let i = 0; i < len; i++) {
                    for (let j = 0; j < len; j++) {
                        newType[j][len - 1 - i] = this.type[i][j];
                    }
                }
                const originalX = this.x;
                this.type = newType;
                if (this.x + this.type[0].length > cols) this.x = cols - this.type[0].length;
                if (this.collides()) {
                    this.type = JSON.parse(JSON.stringify(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]));
                    this.x = Math.floor((cols - this.type[0].length) / 2);
                    this.y = 0;
                }
                sendMidiNote(64, 100); // Mi al rotar
                sendMidiCC();
            }

            move(dx) {
                this.x += dx;
                if (this.x < 0) this.x = 0;
                if (this.x + this.type[0].length > cols) this.x = cols - this.type[0].length;
                if (this.collides()) this.x -= dx;
                const note = dx === -1 ? 60 : 62; // Do (60) a la izquierda, Re (62) a la derecha
                sendMidiNote(note, 100); // Nota al mover
                sendMidiCC();
            }

            update() {
                this.y += this.vy;
                // Reproducir nota mientras cae (varía con la posición Y)
                const fallNote = 60 + Math.floor((this.y / rows) * 12) % 12; // Escala ascendente
                sendMidiNote(fallNote, 80); // Nota más suave mientras cae
                noteDisplay.textContent = `Nota actual: ${fallNote} (C${Math.floor(fallNote / 12) - 1})`; // Mostrar nota
                if (this.collides()) {
                    this.y = Math.floor(this.y);
                    return false;
                }
                return true;
            }

            lock() {
                let noteCount = 0;
                for (let row = 0; row < this.type.length; row++) {
                    for (let col = 0; col < this.type[row].length; col++) {
                        if (this.type[row][col]) {
                            const gridY = Math.floor(this.y) + row;
                            const gridX = this.x + col;
                            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {
                                grid[gridY][gridX] = 1;
                                noteCount++;
                            }
                        }
                    }
                }
                // Asignar notas según el rango de noteCount
                const noteMap = [
                    { range: [1, 2], note: 60 },  // Do
                    { range: [3, 4], note: 62 },  // Re
                    { range: [5, 6], note: 64 },  // Mi
                    { range: [7, 8], note: 65 },  // Fa
                    { range: [9, 10], note: 67 }, // Sol
                    { range: [11, 12], note: 69 }, // La
                    { range: [13, 14], note: 71 }, // Si
                    { range: [15, 16], note: 72 }  // Do
                ];
                const range = noteMap.find(r => noteCount >= r.range[0] && noteCount <= r.range[1]);
                if (range) {
                    sendMidiNote(range.note, 100); // Nota principal al caer
                    // Notas adicionales basadas en los cuadrados que tocan el suelo
                    for (let i = 0; i < Math.min(noteCount, 4); i++) {
                        sendMidiNote(range.note + i, 100); // Hasta 4 notas
                    }
                    noteDisplay.textContent = `Nota al caer: ${range.note} (C${Math.floor(range.note / 12) - 1})`; // Actualizar al caer
                }
                lockedPieces.push({ type: this.type, color: this.color, instrument: this.instrument, x: this.x, y: this.y });
                return new TetrisPiece();
            }

            collides() {
                for (let row = 0; row < this.type.length; row++) {
                    for (let col = 0; col < this.type[row].length; col++) {
                        if (this.type[row][col]) {
                            const newY = Math.floor(this.y) + row + 1;
                            const newX = this.x + col;
                            if (newY >= rows || (newY >= 0 && newX >= 0 && newX < cols && grid[newY][newX])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
        }

        let currentPiece = new TetrisPiece();
        let nextPiece = new TetrisPiece();
        let lastTime = performance.now();
        const dropInterval = 500;
        let isRunning = false;

        function drawGrid() {
            ctx.strokeStyle = '#333';
            for (let i = 0; i <= cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, gameCanvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= rows; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(gameCanvas.width, i * gridSize);
                ctx.stroke();
            }
        }

        function drawLockedPieces() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (grid[row][col]) {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(col * gridSize, row * gridSize, gridSize - 2, gridSize - 2);
                    }
                }
            }
        }

        function drawPreview() {
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            const scale = previewCanvas.width / (nextPiece.type[0].length * gridSize);
            previewCtx.fillStyle = nextPiece.color;
            for (let row = 0; row < nextPiece.type.length; row++) {
                for (let col = 0; col < nextPiece.type[row].length; col++) {
                    if (nextPiece.type[row][col]) {
                        previewCtx.fillRect(
                            col * gridSize * scale,
                            row * gridSize * scale,
                            gridSize * scale - 2,
                            gridSize * scale - 2
                        );
                    }
                }
            }
        }

        function handleKeys(event) {
            if (!isRunning) return;
            switch (event.key) {
                case 'ArrowLeft':
                    currentPiece.move(-1);
                    break;
                case 'ArrowRight':
                    currentPiece.move(1);
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case 'ArrowDown':
                    while (!currentPiece.collides() && currentPiece.y < rows - currentPiece.type.length) {
                        currentPiece.y += 1;
                    }
                    currentPiece.y -= 1;
                    break;
            }
            sendMidiCC();
        }

        document.addEventListener('keydown', handleKeys);
        document.addEventListener('keyup', () => {
            // Detener notas al soltar la tecla
            sendMidiNote(0, 0); // Note Off genérico
        });

        function getTranslatedValueCutOff(value) {
            return Math.round((value / gameCanvas.width) * 127);
        }

        function getTranslatedValueResonance(value) {
            return Math.round((value / gameCanvas.height) * 127);
        }

        function sendMidiCC() {
            const cutOffValue = getTranslatedValueCutOff(currentPiece.x * gridSize);
            const resonanceValue = getTranslatedValueResonance(currentPiece.y * gridSize);
            if (!isNaN(cutOffValue) && cutOffValue >= 0 && cutOffValue <= 127) {
                const ccNumber = 74;
                const ccValue = Math.min(127, Math.max(0, cutOffValue));
                const ccMessage = JSON.stringify({ ccNumber, ccValue });
                if (isOpen(ws)) ws.send(ccMessage);
                console.log(`Sending CC ${ccNumber} with value ${ccValue}`);
            }
            if (!isNaN(resonanceValue) && resonanceValue >= 0 && resonanceValue <= 127) {
                const ccNumber = 42;
                const ccValue = Math.min(127, Math.max(0, resonanceValue));
                const ccMessage = JSON.stringify({ ccNumber, ccValue });
                if (isOpen(ws)) ws.send(ccMessage);
                console.log(`Sending CC ${ccNumber} with value ${ccValue}`);
            }
        }

        function sendMidiNote(note, velocity) {
            if (!isNaN(note) && note >= 0 && note <= 127 && velocity >= 0 && velocity <= 127) {
                const noteOnMessage = JSON.stringify({ ccNumber: 144, ccValue: note, value: velocity });
                const noteOffMessage = JSON.stringify({ ccNumber: 128, ccValue: note, value: 0 });
                if (isOpen(ws)) {
                    ws.send(noteOnMessage);
                    console.log(`Sending Note On: ${note} with velocity ${velocity}`);
                    setTimeout(() => {
                        if (isOpen(ws)) ws.send(noteOffMessage);
                        console.log(`Sending Note Off: ${note}`);
                    }, 200);
                }
            }
        }

        function sendProgramChange(instrument) {
            const pcMessage = JSON.stringify({ ccNumber: 192, ccValue: instrument, value: 0 });
            if (isOpen(ws)) ws.send(pcMessage);
            console.log(`Sending Program Change to instrument ${instrument}`);
        }

        document.getElementById('instrumentSelect').addEventListener('change', (e) => {
            currentPiece.instrument = parseInt(e.target.value);
            sendProgramChange(currentPiece.instrument);
        });

        document.getElementById('startButton').addEventListener('click', () => {
            isRunning = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('endButton').disabled = false;
        });

        document.getElementById('endButton').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('startButton').disabled = false;
            document.getElementById('endButton').disabled = true;
            playLockedPieces();
        });

        function playLockedPieces() {
            console.log('Playing locked pieces');
            lockedPieces.forEach((piece, index) => {
                setTimeout(() => {
                    sendProgramChange(piece.instrument);
                    sendMidiNote(60 + index, 100); // Play note based on index
                }, index * 500); // 500ms delay between pieces
            });
        }

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            if (isRunning && time - lastTime > dropInterval) {
                if (!currentPiece.update()) {
                    const newPiece = currentPiece.lock();
                    currentPiece = newPiece;
                    nextPiece = new TetrisPiece();
                }
                lastTime = time;
            }

            drawGrid();
            drawLockedPieces();
            currentPiece.draw(ctx);
            drawPreview();
        }

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>